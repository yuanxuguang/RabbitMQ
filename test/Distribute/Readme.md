### 消息分发
    RabbitMQ分发消息采用的轮训分发，但是在某种场景下这种策略并不是
    很好，比方说有两个消费者在处理任务，其中有个消费者1处理任务的速度非常快，而另外一个消费者2
    处理速度却很慢，这个时候我们还是采用轮训分发的化就会到这处理速度快的这个消费者很大一部分时间
    处于空闲状态，而处理慢的那个消费者一直在干活，这种分配方式在这种情况下其实就不太好，但是
    RabbitMQ并不知道这种情况它依然很公平的进行分发。

    RabbitMQ 提供了多种消息分发的策略，以下就是其中的一些常见分发策略：
    **默认分发的策略是轮训分发 (Round robin):** 当RabbitMQ有多个消费者在监听一个队列时，它会默认采取轮训策略来分发消息。也就是说，每个消费者会按平均量收到消息。需要注意的是，这种方式并不是完全公平的分发，因为RabbitMQ只是简单地在消费者间轮流分发消息，不考虑每个消费者的消息处理能力。
    **公平分发 (Fair dispatch):** RabbitMQ支持让每个消费者在同一时刻只处理一个消息。只有在消费者处理完成当前消息并确认之后，才会收到下一条消息。这种方式可以实现公平分发，避免某些处理快的消费者始终获取到大量的消息，从而产生消息处理的瓶颈。在 PHP 中，你可以通过设置 basic_qos 来实现公平分发。

```php
/**
 1. $prefetchSize : 能接受的最大的消息体的大小，如果设置为0，则没有最大值的限制。这个参数在 RabbitMQ version 2.x.x 中没有实现，因此无论设为什么值，它都不做任何限制。
 2. $prefetchCount : 指定 RabbitMQ 同一时间对于每一个 Consumer（消费者）发出多少条消息。例如，如果设为1，那么在消费者未确认之前，不会向此消费者发送新的消息。
 3. $global : 这是一个 boolean 值，区别在于 $prefetchCount 的限制是对整个channel 还是每个 consumer。如果设为 true ，则表示对整个channel，否则表示对单个consumer。
 */
$channel->basic_qos(null, 1, null);
$channel->basic_consume('your_queue', '', false, false, false, false, $callback);
```